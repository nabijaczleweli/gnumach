commit f6c9a501febff628fe542ee17ab3d789a4de2ac1
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Oct 31 00:35:57 2016 +0100

    Make multiboot cmdline and modules non-permanent reservations
    
    * i386/i386at/model_dep.c (register_boot_data): For multiboot cmdline,
    module structure, module data and module strings, set
    biosmem_register_boot_data temporary parameter to TRUE.

diff --git a/i386/i386at/model_dep.c b/i386/i386at/model_dep.c
index 239f63f..f57df63 100644
--- a/i386/i386at/model_dep.c
+++ b/i386/i386at/model_dep.c
@@ -280,31 +280,31 @@ register_boot_data(const struct multiboot_raw_info *mbi)
 
 	extern char _start[], _end[];
 
-	/* XXX For now, register all boot data as permanent */
-
 	biosmem_register_boot_data(_kvtophys(&_start), _kvtophys(&_end), FALSE);
 
+	/* cmdline and modules are moved to a safe place by i386at_init.  */
+
 	if ((mbi->flags & MULTIBOOT_LOADER_CMDLINE) && (mbi->cmdline != 0)) {
 		biosmem_register_boot_data(mbi->cmdline,
 					   mbi->cmdline
-					   + strlen((void *)phystokv(mbi->cmdline)) + 1, FALSE);
+					   + strlen((void *)phystokv(mbi->cmdline)) + 1, TRUE);
 	}
 
 	if (mbi->flags & MULTIBOOT_LOADER_MODULES) {
 		i = mbi->mods_count * sizeof(struct multiboot_raw_module);
-		biosmem_register_boot_data(mbi->mods_addr, mbi->mods_addr + i, FALSE);
+		biosmem_register_boot_data(mbi->mods_addr, mbi->mods_addr + i, TRUE);
 
 		tmp = phystokv(mbi->mods_addr);
 
 		for (i = 0; i < mbi->mods_count; i++) {
 			mod = (struct multiboot_raw_module *)tmp + i;
-			biosmem_register_boot_data(mod->mod_start, mod->mod_end, FALSE);
+			biosmem_register_boot_data(mod->mod_start, mod->mod_end, TRUE);
 
 			if (mod->string != 0) {
 				biosmem_register_boot_data(mod->string,
 							   mod->string
 							   + strlen((void *)phystokv(mod->string)) + 1,
-							   FALSE);
+							   TRUE);
 			}
 		}
 	}
@@ -364,7 +364,8 @@ i386at_init(void)
 	kernel_cmdline = (char*) boot_info.cmd_line;
 #else	/* MACH_XEN */
 	/* Copy content pointed by boot_info before losing access to it when it
-	 * is too far in physical memory.  */
+	 * is too far in physical memory.
+	 * Also avoids leaving them in precious areas such as DMA memory.  */
 	if (boot_info.flags & MULTIBOOT_CMDLINE) {
 		int len = strlen ((char*)phystokv(boot_info.cmdline)) + 1;
 		if (! init_alloc_aligned(round_page(len), &addr))
