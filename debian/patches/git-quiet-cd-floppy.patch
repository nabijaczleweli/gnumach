commit abb50be5ea5c374cdb25f05eafdf8afac9b854b1
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Feb 10 00:04:34 2014 +0100

    Add quiet flag to block I/O
    
    This avoids grub & such making Mach print flurries of floppy errors.
    
    * linux/dev/include/linux/blkdev.h (request): Add `quiet' field.
    * linux/dev/include/linux/blk.h (end_request): Print I/O error only if
    the `quiet' field of the request is 0.
    * linux/dev/include/linux/fs.h (ll_rw_block): Add `quiet' parameter.
    * linux/dev/glue/block.c (ll_rw_block): Add `quiet' parameter, copied into
    the request.
    (bread, rdwr_partial, rdwr_full): Pass 0 to `ll_rw_block''s `quiet' parameter.
    * linux/dev/drivers/block/floppy.c (floppy_revalidate): Pass 1 to
    `ll_rw_block''s `quiet' parameter.

diff --git a/linux/dev/drivers/block/floppy.c b/linux/dev/drivers/block/floppy.c
index 4c0977a..83d66f0 100644
--- a/linux/dev/drivers/block/floppy.c
+++ b/linux/dev/drivers/block/floppy.c
@@ -3723,7 +3723,7 @@ static int floppy_revalidate(kdev_t dev)
 				return 1;
 			}
 			if (bh && !buffer_uptodate(bh))
-				ll_rw_block(READ, 1, &bh);
+				ll_rw_block(READ, 1, &bh, 1);
 			process_fd_request();
 			wait_on_buffer(bh);
 			brelse(bh);
diff --git a/linux/dev/glue/block.c b/linux/dev/glue/block.c
index 011b6f5..ce4c633 100644
--- a/linux/dev/glue/block.c
+++ b/linux/dev/glue/block.c
@@ -384,7 +384,7 @@ bread (kdev_t dev, int block, int size)
   bh = getblk (dev, block, size);
   if (bh)
     {
-      ll_rw_block (READ, 1, &bh);
+      ll_rw_block (READ, 1, &bh, 0);
       wait_on_buffer (bh);
       if (! buffer_uptodate (bh))
 	{
@@ -444,7 +444,7 @@ enqueue_request (struct request *req)
 /* Perform the I/O operation RW on the buffer list BH
    containing NR buffers.  */
 void
-ll_rw_block (int rw, int nr, struct buffer_head **bh)
+ll_rw_block (int rw, int nr, struct buffer_head **bh, int quiet)
 {
   int i, bshift, bsize;
   unsigned major;
@@ -476,6 +476,7 @@ ll_rw_block (int rw, int nr, struct buffer_head **bh)
   r->rq_dev = bh[0]->b_dev;
   r->cmd = rw;
   r->errors = 0;
+  r->quiet = quiet;
   r->sector = bh[0]->b_blocknr << (bshift - 9);
   r->current_nr_sectors = bh[0]->b_size >> 9;
   r->buffer = bh[0]->b_data;
@@ -528,7 +529,7 @@ rdwr_partial (int rw, kdev_t dev, loff_t *off,
   bh->b_data = alloc_buffer (bh->b_size);
   if (! bh->b_data)
     return -ENOMEM;
-  ll_rw_block (READ, 1, &bh);
+  ll_rw_block (READ, 1, &bh, 0);
   wait_on_buffer (bh);
   if (buffer_uptodate (bh))
     {
@@ -542,7 +543,7 @@ rdwr_partial (int rw, kdev_t dev, loff_t *off,
 	{
 	  memcpy (bh->b_data + o, *buf, c);
 	  bh->b_state = (1 << BH_Dirty) | (1 << BH_Lock);
-	  ll_rw_block (WRITE, 1, &bh);
+	  ll_rw_block (WRITE, 1, &bh, 0);
 	  wait_on_buffer (bh);
 	  if (! buffer_uptodate (bh))
 	    {
@@ -623,7 +624,7 @@ rdwr_full (int rw, kdev_t dev, loff_t *off, char **buf, int *resid, int bshift)
     }
   if (! err)
     {
-      ll_rw_block (rw, i, bhp);
+      ll_rw_block (rw, i, bhp, 0);
       wait_on_buffer (bhp[i - 1]);
     }
   for (bh = bhead, cc = 0, j = 0; j < i; cc += bh->b_size, bh++, j++)
diff --git a/linux/dev/include/linux/blk.h b/linux/dev/include/linux/blk.h
index 412b864..156d91c 100644
--- a/linux/dev/include/linux/blk.h
+++ b/linux/dev/include/linux/blk.h
@@ -391,8 +391,9 @@ static void end_request(int uptodate) {
 
 	req->errors = 0;
 	if (!uptodate) {
-		printk("end_request: I/O error, dev %s, sector %lu\n",
-			kdevname(req->rq_dev), req->sector);
+		if (!req->quiet)
+			printk("end_request: I/O error, dev %s, sector %lu\n",
+				kdevname(req->rq_dev), req->sector);
 #ifdef MACH
 		for (bh = req->bh; bh; )
 		  {
diff --git a/linux/dev/include/linux/blkdev.h b/linux/dev/include/linux/blkdev.h
index e9a40d7..5bf0a28 100644
--- a/linux/dev/include/linux/blkdev.h
+++ b/linux/dev/include/linux/blkdev.h
@@ -23,6 +23,7 @@ struct request {
 	kdev_t rq_dev;
 	int cmd;		/* READ or WRITE */
 	int errors;
+	int quiet;
 	unsigned long sector;
 	unsigned long nr_sectors;
 	unsigned long current_nr_sectors;
diff --git a/linux/dev/include/linux/fs.h b/linux/dev/include/linux/fs.h
index 740ebb5..37f7173 100644
--- a/linux/dev/include/linux/fs.h
+++ b/linux/dev/include/linux/fs.h
@@ -733,7 +733,7 @@ extern struct file * get_empty_filp(void);
 extern int close_fp(struct file *filp);
 extern struct buffer_head * get_hash_table(kdev_t dev, int block, int size);
 extern struct buffer_head * getblk(kdev_t dev, int block, int size);
-extern void ll_rw_block(int rw, int nr, struct buffer_head * bh[]);
+extern void ll_rw_block(int rw, int nr, struct buffer_head * bh[], int quiet);
 extern void ll_rw_page(int rw, kdev_t dev, unsigned long nr, char * buffer);
 extern void ll_rw_swap_file(int rw, kdev_t dev, unsigned int *b, int nb, char *buffer);
 extern int is_read_only(kdev_t dev);
commit 55cdcf3ad3ebec3d9899130fe435a59f8e9e1617
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Feb 10 00:19:30 2014 +0100

    Add quiet flag to CD I/O
    
    * linux/src/drivers/block/ide-cd.c (cdrom_queue_packet_command): Add `quiet'
    parameter, copied into the request.
    (cdrom_decode_status): Do not print I/O error when `quiet' field of
    request is non-zero.
    (cdrom_end_request): Do not print sense results when `quiet' field of
    request is non-zero.
    (cdrom_check_status, cdrom_read_capacity, cdrom_read_tocentry): Pass 1 to
    `cdrom_queue_packet_command''s `quiet' parameter.
    (cdrom_lockdoor, cdrom_eject, cdrom_pause, cdrom_startstop,
    cdrom_read_subchannel, cdrom_mode_sense, cdrom_mode_select,
    cdrom_play_lba_range_1, cdrom_read_block, cdrom_load_unload,
    ide_cdrom_ioctl): Pass 0 to `cdrom_queue_packet_command''s `quiet' parameter.

diff --git a/linux/src/drivers/block/ide-cd.c b/linux/src/drivers/block/ide-cd.c
index e4548f5..ccf7954 100644
--- a/linux/src/drivers/block/ide-cd.c
+++ b/linux/src/drivers/block/ide-cd.c
@@ -649,7 +649,7 @@ static void cdrom_end_request (int uptodate, ide_drive_t *drive)
 {
 	struct request *rq = HWGROUP(drive)->rq;
 
-	if (rq->cmd == REQUEST_SENSE_COMMAND && uptodate) {
+	if (rq->cmd == REQUEST_SENSE_COMMAND && uptodate && !rq->quiet) {
 		struct packet_command *pc = (struct packet_command *)
 			                      rq->buffer;
 		cdrom_analyze_sense_data (drive,
@@ -727,16 +727,18 @@ static int cdrom_decode_status (ide_drive_t *drive, int good_stat,
 				   because workman constantly polls the drive
 				   with this command, and we don't want
 				   to uselessly fill up the syslog. */
-				if (pc->c[0] != SCMD_READ_SUBCHANNEL)
+				if (pc->c[0] != SCMD_READ_SUBCHANNEL && !rq->quiet)
 					printk ("%s : tray open or drive not ready\n",
 						drive->name);
 			} else if (sense_key == UNIT_ATTENTION) {
 				/* Check for media change. */
 				cdrom_saw_media_change (drive);
-				printk ("%s: media changed\n", drive->name);
+				if (!rq->quiet)
+					printk ("%s: media changed\n", drive->name);
 			} else {
 				/* Otherwise, print an error. */
-				ide_dump_status (drive, "packet command error",
+				if (!rq->quiet)
+					ide_dump_status (drive, "packet command error",
 						 stat);
 			}
 			
@@ -768,7 +770,8 @@ static int cdrom_decode_status (ide_drive_t *drive, int good_stat,
 				cdrom_saw_media_change (drive);
 
 				/* Fail the request. */
-				printk ("%s : tray open\n", drive->name);
+				if (!rq->quiet)
+					printk ("%s : tray open\n", drive->name);
 				cdrom_end_request (0, drive);
 			} else if (sense_key == UNIT_ATTENTION) {
 				/* Media change. */
@@ -783,7 +786,8 @@ static int cdrom_decode_status (ide_drive_t *drive, int good_stat,
 				   sense_key == DATA_PROTECT) {
 				/* No point in retrying after an illegal
 				   request or data protect error.*/
-				ide_dump_status (drive, "command error", stat);
+				if (!rq->quiet)
+					ide_dump_status (drive, "command error", stat);
 				cdrom_end_request (0, drive);
 			} else if ((err & ~ABRT_ERR) != 0) {
 				/* Go to the default handler
@@ -1406,7 +1410,7 @@ void cdrom_sleep (int time)
 #endif
 
 static
-int cdrom_queue_packet_command (ide_drive_t *drive, struct packet_command *pc)
+int cdrom_queue_packet_command (ide_drive_t *drive, struct packet_command *pc, int quiet)
 {
 	struct atapi_request_sense my_reqbuf;
 	int retries = 10;
@@ -1423,6 +1427,7 @@ int cdrom_queue_packet_command (ide_drive_t *drive, struct packet_command *pc)
 		ide_init_drive_cmd (&req);
 		req.cmd = PACKET_COMMAND;
 		req.buffer = (char *)pc;
+		req.quiet = quiet;
 		(void) ide_do_drive_cmd (drive, &req, ide_wait);
 
 		if (pc->stat != 0) {
@@ -1563,7 +1568,7 @@ cdrom_check_status (ide_drive_t  *drive,
 
         pc.c[7] = CDROM_STATE_FLAGS (drive)->sanyo_slot % 3;
 
-	return cdrom_queue_packet_command (drive, &pc);
+	return cdrom_queue_packet_command (drive, &pc, 1);
 }
 
 
@@ -1588,7 +1593,7 @@ cdrom_lockdoor (ide_drive_t *drive, int lockflag,
 
 		pc.c[0] = ALLOW_MEDIUM_REMOVAL;
 		pc.c[4] = (lockflag != 0);
-		stat = cdrom_queue_packet_command (drive, &pc);
+		stat = cdrom_queue_packet_command (drive, &pc, 0);
 	}
 
 	if (stat == 0)
@@ -1622,7 +1627,7 @@ cdrom_eject (ide_drive_t *drive, int ejectflag,
 
 	pc.c[0] = START_STOP;
 	pc.c[4] = 2 + (ejectflag != 0);
-	return cdrom_queue_packet_command (drive, &pc);
+	return cdrom_queue_packet_command (drive, &pc, 0);
 }
 
 
@@ -1637,7 +1642,7 @@ cdrom_pause (ide_drive_t *drive, int pauseflag,
 
 	pc.c[0] = SCMD_PAUSE_RESUME;
 	pc.c[8] = !pauseflag;
-	return cdrom_queue_packet_command (drive, &pc);
+	return cdrom_queue_packet_command (drive, &pc, 0);
 }
 
 
@@ -1653,7 +1658,7 @@ cdrom_startstop (ide_drive_t *drive, int startflag,
 	pc.c[0] = START_STOP;
 	pc.c[1] = 1;
 	pc.c[4] = startflag;
-	return cdrom_queue_packet_command (drive, &pc);
+	return cdrom_queue_packet_command (drive, &pc, 0);
 }
 
 
@@ -1676,7 +1681,7 @@ cdrom_read_capacity (ide_drive_t *drive, unsigned *capacity,
 	pc.buffer = (unsigned char *)&capbuf;
 	pc.buflen = sizeof (capbuf);
 
-	stat = cdrom_queue_packet_command (drive, &pc);
+	stat = cdrom_queue_packet_command (drive, &pc, 1);
 	if (stat == 0)
 		*capacity = ntohl (capbuf.lba);
 
@@ -1702,7 +1707,7 @@ cdrom_read_tocentry (ide_drive_t *drive, int trackno, int msf_flag,
 	pc.c[8] = (buflen & 0xff);
 	pc.c[9] = (format << 6);
 	if (msf_flag) pc.c[1] = 2;
-	return cdrom_queue_packet_command (drive, &pc);
+	return cdrom_queue_packet_command (drive, &pc, 1);
 }
 
 
@@ -1834,7 +1839,7 @@ cdrom_read_subchannel (ide_drive_t *drive, int format,
 	pc.c[3] = format,
 	pc.c[7] = (buflen >> 8);
 	pc.c[8] = (buflen & 0xff);
-	return cdrom_queue_packet_command (drive, &pc);
+	return cdrom_queue_packet_command (drive, &pc, 0);
 }
 
 
@@ -1855,7 +1860,7 @@ cdrom_mode_sense (ide_drive_t *drive, int pageno, int modeflag,
 	pc.c[2] = pageno | (modeflag << 6);
 	pc.c[7] = (buflen >> 8);
 	pc.c[8] = (buflen & 0xff);
-	return cdrom_queue_packet_command (drive, &pc);
+	return cdrom_queue_packet_command (drive, &pc, 0);
 }
 
 
@@ -1875,7 +1880,7 @@ cdrom_mode_select (ide_drive_t *drive, int pageno, char *buf, int buflen,
 	pc.c[2] = pageno;
 	pc.c[7] = (buflen >> 8);
 	pc.c[8] = (buflen & 0xff);
-	return cdrom_queue_packet_command (drive, &pc);
+	return cdrom_queue_packet_command (drive, &pc, 0);
 }
 
 
@@ -1903,7 +1908,7 @@ cdrom_play_lba_range_1 (ide_drive_t *drive, int lba_start, int lba_end,
 	}
 #endif /* not STANDARD_ATAPI */
 
-	return cdrom_queue_packet_command (drive, &pc);
+	return cdrom_queue_packet_command (drive, &pc, 0);
 }
 
 
@@ -2004,7 +2009,7 @@ cdrom_read_block (ide_drive_t *drive, int format, int lba, int nblocks,
 	else
 		pc.c[9] = 0x10;
 
-	stat = cdrom_queue_packet_command (drive, &pc);
+	stat = cdrom_queue_packet_command (drive, &pc, 0);
 
 #if ! STANDARD_ATAPI
 	/* If the drive doesn't recognize the READ CD opcode, retry the command
@@ -2059,7 +2064,7 @@ cdrom_load_unload (ide_drive_t *drive, int slot,
 		pc.c[0] = LOAD_UNLOAD;
 		pc.c[4] = 2 + (slot >= 0);
 		pc.c[8] = slot;
-		return cdrom_queue_packet_command (drive, &pc);
+		return cdrom_queue_packet_command (drive, &pc, 0);
 
 	}
 }
@@ -2575,7 +2580,7 @@ int ide_cdrom_ioctl (ide_drive_t *drive, struct inode *inode,
 				pc.buffer = buf;
 			}
 
-			stat = cdrom_queue_packet_command (drive, &pc);
+			stat = cdrom_queue_packet_command (drive, &pc, 0);
 
 			if (len > 0)
 				memcpy_tofs ((void *)arg, buf, len);
commit be41c805265881172e8004c81dd646ad579c8009
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Mon Feb 10 00:41:49 2014 +0100

    Make open return ENXIO on missing CD-ROM
    
    * linux/src/drivers/block/ide-cd.c (ide_cdrom_open): Return -ENXIO when
    CD sense failed.

diff --git a/linux/src/drivers/block/ide-cd.c b/linux/src/drivers/block/ide-cd.c
index ccf7954..020a831 100644
--- a/linux/src/drivers/block/ide-cd.c
+++ b/linux/src/drivers/block/ide-cd.c
@@ -2643,6 +2643,10 @@ int ide_cdrom_open (struct inode *ip, struct file *fp, ide_drive_t *drive)
 		if (stat == 0 || my_reqbuf.sense_key == UNIT_ATTENTION) {
 			(void) cdrom_lockdoor (drive, 1, &my_reqbuf);
 			(void) cdrom_read_toc (drive, &my_reqbuf);
+		} else {
+			/* Otherwise return as missing */
+			--drive->usage;
+			return -ENXIO;
 		}
 	}
 
