#DPATCHLEVEL=1

Current GNU Mach provides Linux's "software interrupts" (bottom
halves) by calling 'linux_soft_intr' during spl switches and Linux's
schedule() call.
However, Mach has support for software interrupts or similar,
obscurely called 'ASTs' (see kern/ast.c).

This patch make the glue use Mach AST's and remove the invasive (IMHO)
SPL's hacks and let schedule() just block the thread, not making it
deal with software interrupts.


2006-02-01  Gianluca Guida  <glguida@gmail.com>

	* i386/i386/spl.S (spl0) [LINUX_DEV]: Removed linux glue dependant
	code for calling linux_soft_intr.
	(splx_cli) [LINUX_DEV]: Likewise.

	* kern/ast.h (AST_LINUX20): New macro.
	* kern/ast.c (ast_taken): Call linux_ast() on AST_LINUX20 reason.

	* linux/dev/kernel/sched.c (handle_soft_intr): Function removed.
	(schedule): Do not call handle_soft_intr() anymore.
	* linux/dev/kenrel/softirq.c (linux_soft_intr): Changed name into ...
	(linux_ast): ... this.
	* linux/src/include/linux/interrupt.h: Include <kern/ast.h>.
	(mark_bh): Call ast_on() with reason AST_LINUX20.


diff -ru gnumach-vanilla/i386/i386/spl.S gnumach-lessglueisbetter/i386/i386/spl.S
--- gnumach-vanilla/i386/i386/spl.S	1997-02-25 22:27:11.000000000 +0100
+++ gnumach-lessglueisbetter/i386/i386/spl.S	2006-01-28 04:12:00.000000000 +0100
@@ -55,18 +55,6 @@
 	movl	EXT(curr_ipl),%eax	/* save current ipl */
 	pushl	%eax
 	cli				/* disable interrupts */
-#ifdef LINUX_DEV
-	movl	EXT(bh_active),%eax
-					/* get pending mask */
-	andl	EXT(bh_mask),%eax	/* any pending unmasked interrupts? */
-	jz	1f			/* no, skip */
-	call	EXT(spl1)		/* block further interrupts */
-	incl	EXT(intr_count)		/* set interrupt flag */
-	call	EXT(linux_soft_intr)	/* go handle interrupt */
-	decl	EXT(intr_count)		/* decrement interrupt flag */
-	cli				/* disable interrupts */
-1:
-#endif
 	cmpl	$0,softclkpending	/* softclock pending? */
 	je	1f			/* no, skip */
 	movl	$0,softclkpending	/* clear flag */
@@ -146,18 +134,6 @@
 	cli				/* disable interrupts */
 	testl	%edx,%edx		/* spl0? */
 	jnz	2f			/* no, skip */
-#ifdef LINUX_DEV
-	movl	EXT(bh_active),%eax
-					/* get pending mask */
-	andl	EXT(bh_mask),%eax	/* any pending unmasked interrupts? */
-	jz	1f			/* no, skip */
-	call	EXT(spl1)		/* block further interrupts */
-	incl	EXT(intr_count)		/* set interrupt flag */
-	call	EXT(linux_soft_intr)	/* go handle interrupt */
-	decl	EXT(intr_count)		/* decrement interrupt flag */
-	cli				/* disable interrupts */
-1:
-#endif
 	cmpl	$0,softclkpending	/* softclock pending? */
 	je	1f			/* no, skip */
 	movl	$0,softclkpending	/* clear flag */

diff -ru gnumach-vanilla/kern/ast.c gnumach-lessglueisbetter/kern/ast.c
--- gnumach-vanilla/kern/ast.c	2001-04-05 08:39:20.000000000 +0200
+++ gnumach-lessglueisbetter/kern/ast.c	2006-01-27 17:02:19.000000000 +0100
@@ -54,7 +54,7 @@
 #include <mach/policy.h>
 #endif	/* MACH_FIXPRI */
 
-
+extern void linux_ast();
 volatile ast_t need_ast[NCPUS];
 
 void
@@ -90,6 +90,9 @@
 	if (reasons & AST_NETWORK)
 		net_ast();
 
+	if (reasons & AST_LINUX20)
+	  	linux_ast();
+
 #if	NORMA_IPC
 	if (reasons & AST_NETIPC)
 		netipc_ast();
diff -ru gnumach-vanilla/kern/ast.h gnumach-lessglueisbetter/kern/ast.h
--- gnumach-vanilla/kern/ast.h	2001-04-05 08:39:20.000000000 +0200
+++ gnumach-lessglueisbetter/kern/ast.h	2006-01-27 17:01:53.000000000 +0100
@@ -56,6 +56,7 @@
 #define AST_BLOCK	0x4
 #define AST_NETWORK	0x8
 #define AST_NETIPC	0x10
+#define AST_LINUX20	0x20
 
 #define	AST_SCHEDULING	(AST_HALT|AST_TERMINATE|AST_BLOCK)
 
diff -ru gnumach-vanilla/linux/dev/kernel/sched.c gnumach-lessglueisbetter/linux/dev/kernel/sched.c
--- gnumach-vanilla/linux/dev/kernel/sched.c	1999-04-26 07:49:38.000000000 +0200
+++ gnumach-lessglueisbetter/linux/dev/kernel/sched.c	2006-01-27 18:29:28.000000000 +0100
@@ -51,7 +51,6 @@
 extern void free_contig_mem (vm_page_t);
 extern spl_t splhigh (void);
 extern spl_t splx (spl_t);
-extern void linux_soft_intr (void);
 extern int issig (void);
 extern int printf (const char *, ...);
 extern int linux_auto_config;
@@ -64,17 +63,6 @@
 
 static struct wait_queue **auto_config_queue;
 
-static inline void
-handle_soft_intr (void)
-{
-  if (bh_active & bh_mask)
-    {
-      intr_count = 1;
-      linux_soft_intr ();
-      intr_count = 0;
-    }
-}
-
 static void
 tqueue_bh (void)
 {
@@ -318,7 +318,6 @@
     printk ("Aiee: scheduling in interrupt %p\n",
 	    __builtin_return_address (0));
   
-  handle_soft_intr ();
   run_task_queue (&tq_scheduler);
 
   if (!linux_auto_config)
@@ -635,8 +622,4 @@
   mark_bh (TIMER_BH);
   if (tq_timer)
     mark_bh (TQUEUE_BH);
-#if 0
-  if (linux_timer_print)
-    printf ("linux_timer_intr: pic_mask[0] %x\n", pic_mask[0]);
-#endif
 }
 
diff -ru gnumach-vanilla/linux/dev/kernel/softirq.c gnumach-lessglueisbetter/linux/dev/kernel/softirq.c
--- gnumach-vanilla/linux/dev/kernel/softirq.c	1999-04-26 07:49:38.000000000 +0200
+++ gnumach-lessglueisbetter/linux/dev/kernel/softirq.c	2006-01-27 15:58:33.000000000 +0100
@@ -19,7 +19,7 @@
 void (*bh_base[32]) (void);

 void
-linux_soft_intr (void)
+linux_ast (void)
 {
   unsigned long active;
   unsigned long mask, left;

diff -ru gnumach-vanilla/linux/src/include/linux/interrupt.h gnumach-lessglueisbetter/linux/src/include/linux/interrupt.h
--- gnumach-vanilla/linux/src/include/linux/interrupt.h	1999-04-26 07:56:35.000000000 +0200
+++ gnumach-lessglueisbetter/linux/src/include/linux/interrupt.h	2006-01-27 17:08:54.000000000 +0100
@@ -2,6 +2,7 @@
 #ifndef _LINUX_INTERRUPT_H
 #define _LINUX_INTERRUPT_H
 
+#include <kern/ast.h>
 #include <linux/kernel.h>
 #include <asm/bitops.h>
 
@@ -53,6 +54,7 @@
 extern inline void mark_bh(int nr)
 {
 	set_bit(nr, &bh_active);
+	ast_on (cpu_number(), AST_LINUX20);
 }
 
 /*

