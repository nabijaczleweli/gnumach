commit dccf8be4b40ede12941ff347781fbff9330b2280
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Wed Nov 12 14:18:55 2014 +0100

    Pass ide and hd kernel options to ide driver
    
    * linux/dev/drivers/block/genhd.c: Include <linux/hdreg.h> and
    <alloca.h>
    (device_setup): Look for ide and hd options, and call ide_setup with
    them.
    * linux/src/drivers/block/ide.c (ide_setup) [MACH]: Parse hd[0-7] instead
    of hd[a-h].

diff --git a/linux/dev/drivers/block/genhd.c b/linux/dev/drivers/block/genhd.c
index 95b499b..3a86138 100644
--- a/linux/dev/drivers/block/genhd.c
+++ b/linux/dev/drivers/block/genhd.c
@@ -27,6 +27,8 @@
 #ifdef CONFIG_BLK_DEV_INITRD
 #include <linux/blk.h>
 #endif
+#include <linux/hdreg.h>
+#include <alloca.h>
 
 #include <asm/system.h>
 
@@ -768,12 +770,36 @@ static void setup_dev(struct gendisk *dev)
 void device_setup(void)
 {
 	extern void console_map_init(void);
+	extern char *kernel_cmdline;
+	char *c, *param, *white;
 	struct gendisk *p;
 	int nr=0;
 #ifdef MACH
 	linux_intr_pri = SPL6;
 #endif
 
+	for (c = kernel_cmdline; c; )
+	{
+		param = strstr(c, " ide");
+		if (!param)
+			param = strstr(c, " hd");
+		if (!param)
+			break;
+		if (param) {
+			param++;
+			white = strchr(param, ' ');
+			if (!white) {
+				ide_setup(param);
+				c = NULL;
+			} else {
+				char *word = alloca(white - param + 1);
+				strncpy(word, param, white - param);
+				word[white-param] = '\0';
+				ide_setup(word);
+				c = white + 1;
+			}
+		}
+	}
 #ifndef MACH
 	chr_dev_init();
 #endif
diff --git a/linux/src/drivers/block/ide.c b/linux/src/drivers/block/ide.c
index 9b9ecc2..7b639f7 100644
--- a/linux/src/drivers/block/ide.c
+++ b/linux/src/drivers/block/ide.c
@@ -3152,7 +3152,11 @@ void ide_setup (char *s)
 	ide_hwif_t *hwif;
 	ide_drive_t *drive;
 	unsigned int hw, unit;
+#ifdef MACH
+	const char max_drive = '0' + ((MAX_HWIFS * MAX_DRIVES) - 1);
+#else
 	const char max_drive = 'a' + ((MAX_HWIFS * MAX_DRIVES) - 1);
+#endif
 	const char max_hwif  = '0' + (MAX_HWIFS - 1);
 
 	printk("ide_setup: %s", s);
@@ -3161,11 +3165,19 @@ void ide_setup (char *s)
 	/*
 	 * Look for drive options:  "hdx="
 	 */
+#ifdef MACH
+	if (s[0] == 'h' && s[1] == 'd' && s[2] >= '0' && s[2] <= max_drive) {
+#else
 	if (s[0] == 'h' && s[1] == 'd' && s[2] >= 'a' && s[2] <= max_drive) {
+#endif
 		const char *hd_words[] = {"none", "noprobe", "nowerr", "cdrom",
 				"serialize", "autotune", "noautotune",
 				"slow", "ide-scsi", NULL};
+#ifdef MACH
+		unit = s[2] - '0';
+#else
 		unit = s[2] - 'a';
+#endif
 		hw   = unit / MAX_DRIVES;
 		unit = unit % MAX_DRIVES;
 		hwif = &ide_hwifs[hw];
commit acf1525f4dec4088c075e4d7847be7305873a3a9
Author: Samuel Thibault <samuel.thibault@ens-lyon.org>
Date:   Thu Nov 13 01:25:29 2014 +0100

    Add nodma options
    
    Some very slow qemu instances would eventually trigger DMA timeouts,
    let's give a way to disable DMA there, it does not actually slow down
    operations anyway.
    
    * linux/src/drivers/block/ide.h (ide_drive_s): Add nodma field.
    * linux/src/drivers/block/ide.c (do_identify): Do not call
    dmaproc(ide_dma_check) when nodma is 1.
    (ide_setup): Add nodma option.

diff --git a/linux/src/drivers/block/ide.c b/linux/src/drivers/block/ide.c
index 7b639f7..41a2601 100644
--- a/linux/src/drivers/block/ide.c
+++ b/linux/src/drivers/block/ide.c
@@ -2526,7 +2526,7 @@ static inline void do_identify (ide_drive_t *drive, byte cmd)
 					drive->media = ide_tape;
 					drive->present = 1;
 					drive->removable = 1;
-					if (drive->autotune != 2 && HWIF(drive)->dmaproc != NULL) {
+					if (drive->autotune != 2 && HWIF(drive)->dmaproc != NULL && !drive->nodma) {
 						if (!HWIF(drive)->dmaproc(ide_dma_check, drive))
 							printk(", DMA");
 					}
@@ -2653,7 +2653,7 @@ static inline void do_identify (ide_drive_t *drive, byte cmd)
 		if (drive->mult_req || ((id->multsect_valid & 1) && id->multsect))
 			drive->special.b.set_multmode = 1;
 	}
-	if (drive->autotune != 2 && HWIF(drive)->dmaproc != NULL) {
+	if (drive->autotune != 2 && HWIF(drive)->dmaproc != NULL && !drive->nodma) {
 		if (!(HWIF(drive)->dmaproc(ide_dma_check, drive))) {
 			if ((id->field_valid & 4) && (id->dma_ultra & (id->dma_ultra >> 8) & 7))
 				printk(", UDMA");
@@ -3108,6 +3108,7 @@ static int match_parm (char *s, const char *keywords[], int vals[], int max_vals
  *				Not fully supported by all chipset types,
  *				and quite likely to cause trouble with
  *				older/odd IDE drives.
+ * "hdx=nodma"		: disallow DMA for the drive
  *
  * "idebus=xx"		: inform IDE driver of VESA/PCI bus speed in Mhz,
  *				where "xx" is between 20 and 66 inclusive,
@@ -3172,7 +3173,7 @@ void ide_setup (char *s)
 #endif
 		const char *hd_words[] = {"none", "noprobe", "nowerr", "cdrom",
 				"serialize", "autotune", "noautotune",
-				"slow", "ide-scsi", NULL};
+				"slow", "ide-scsi", "nodma", NULL};
 #ifdef MACH
 		unit = s[2] - '0';
 #else
@@ -3212,6 +3213,9 @@ void ide_setup (char *s)
 			case -9: /* "ide-scsi" */
 				drive->ide_scsi = 1;
 				goto done;
+			case -10: /* "nodma" */
+				drive->nodma = 1;
+				goto done;
 			case 3: /* cyl,head,sect */
 				drive->media	= ide_disk;
 				drive->cyl	= drive->bios_cyl  = vals[0];
diff --git a/linux/src/drivers/block/ide.h b/linux/src/drivers/block/ide.h
index edeedc9..28e371b 100644
--- a/linux/src/drivers/block/ide.h
+++ b/linux/src/drivers/block/ide.h
@@ -344,6 +344,7 @@ typedef struct ide_drive_s {
 	unsigned nobios		: 1;	/* flag: do not probe bios for drive */
 	unsigned slow		: 1;	/* flag: slow data port */
 	unsigned autotune	: 2;	/* 1=autotune, 2=noautotune, 0=default */
+	unsigned nodma		: 1;	/* disk should not use dma for read/write */
 #if FAKE_FDISK_FOR_EZDRIVE
 	unsigned remap_0_to_1	: 1;	/* flag: partitioned with ezdrive */
 #endif /* FAKE_FDISK_FOR_EZDRIVE */
