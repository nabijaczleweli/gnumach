#DPATCHLEVEL=1

2006-01-14  Samuel Thibault  <samuel.thibault@ens-lyon.org>

	Fix ps2 mouse driver command reception.

	* kd_mouse.c: Remove mouse_char_in and mouse_char variables.
	Add mouse_char_index variable.
	(mouse_handle_byte): Use mousebuf instead of mouse_char for
	storing incoming command characters.
	(kd_mouse_read): Use mousebuf instead of mouse_char
	for getting incoming command characters.
	(kd_mouse_read_reset): New function.
	(ibm_ps2_mouse_open,ibm_ps2_mouse_close): Call new
	kd_mouse_read_reset function.


--- gnumach-20050801/i386/i386at/kd_mouse.c	2001-04-05 08:39:21.000000000 +0200
+++ gnumach-mine/i386/i386at/kd_mouse.c	2006-01-14 22:49:41.000000000 +0100
@@ -122,8 +122,7 @@
 
 boolean_t	mouse_char_cmd = FALSE;		/* mouse response is to cmd */
 boolean_t	mouse_char_wanted = FALSE;	/* want mouse response */
-boolean_t	mouse_char_in = FALSE;		/* have mouse response */
-unsigned char	mouse_char;			/* mouse response */
+int		mouse_char_index;		/* mouse response */
 
 
 /*
@@ -573,11 +572,11 @@ mouse_handle_byte(ch)
 	    /*
 	     *	Mouse character is response to command
 	     */
-	    mouse_char = ch;
-	    mouse_char_in = TRUE;
+	    if (mousebufindex < mousebufsize)
+	        mousebuf[mousebufindex++] = ch;
 	    if (mouse_char_wanted) {
 		mouse_char_wanted = FALSE;
-		wakeup(&mouse_char);
+		wakeup(&mousebuf);
 	    }
 	    return;
 	}
@@ -747,22 +746,33 @@ int kd_mouse_read(void)
 {
 	int	ch;
 
-	while (!mouse_char_in) {
+	if (mouse_char_index >= mousebufsize)
+	    return -1;
+
+	while (mousebufindex <= mouse_char_index) {
 	    mouse_char_wanted = TRUE;
 #ifdef	MACH_KERNEL
-	    assert_wait((event_t) &mouse_char, FALSE);
+	    assert_wait((event_t) &mousebuf, FALSE);
 	    thread_block((void (*)()) 0);
 #else	/* MACH_KERNEL */
-	    sleep(&mouse_char, PZERO);
+	    sleep(&mousebuf, PZERO);
 #endif	/* MACH_KERNEL */
 	}
 
-	ch = mouse_char;
-	mouse_char_in = FALSE;
+	ch = mousebuf[mouse_char_index++];
 
 	return ch;
 }
 
+/*
+ *	Prepare buffer for receiving next packet from mouse.
+ */
+void kd_mouse_read_reset(void)
+{
+	mousebufindex = 0;
+	mouse_char_index = 0;
+}
+
 ibm_ps2_mouse_open(dev)
 {
 	spl_t	s = spltty();
@@ -775,6 +785,7 @@ ibm_ps2_mouse_open(dev)
 	kd_cmdreg_write(0x47);	/* allow mouse interrupts */
 				/* magic number for ibm? */
 
+	kd_mouse_read_reset();
 	kd_mouse_write(0xff);	/* reset mouse */
 	if (kd_mouse_read() != 0xfa) {
 	    splx(s);
@@ -784,18 +795,21 @@ ibm_ps2_mouse_open(dev)
 	(void) kd_mouse_read();	/* discard 2-character mouse ID */
 	(void) kd_mouse_read();
 
+	kd_mouse_read_reset();
 	kd_mouse_write(0xea);	/* set stream mode */
 	if (kd_mouse_read() != 0xfa) {
 	    splx(s);
 	    return;		/* need ACK */
 	}
 
+	kd_mouse_read_reset();
 	kd_mouse_write(0xf4);	/* enable */
 	if (kd_mouse_read() != 0xfa) {
 	    splx(s);
 	    return;		/* need ACK */
 	}
 
+	kd_mouse_read_reset();
 	mouse_char_cmd = FALSE;	/* now we get mouse packets */
 
 	splx(s);
@@ -807,6 +821,7 @@ ibm_ps2_mouse_close(dev)
 
 	mouse_char_cmd = TRUE;	/* responses are to commands */
 
+	kd_mouse_read_reset();
 	kd_mouse_write(0xff);	/* reset mouse */
 	if (kd_mouse_read() == 0xfa) {
 	    /* got ACK: discard 2-char mouse ID */

