2009-06-11  Samuel Thibault  <samuel.thibault@ens-lyon.org>

	* i386/i386at/model_dep.c (mem_size_init): Reserve 128MiB for virtual
	memory space, to make room for the zalloc area.

2008-12-29  Samuel Thibault  <samuel.thibault@ens-lyon.org>

	* kern/zalloc.c (zone_map_size): Increase from 12 to 64 MiB.

2007-12-30  Samuel Thibault  <samuel.thibault@ens-lyon.org>

	* vm/vm_map.h (VM_MAP_COPY_PAGE_LIST_MAX): Increase to 64.

2007-08-20  Samuel Thibault  <samuel.thibault@ens-lyon.org>

	* vm/vm_object.c (vm_object_cached_max): Increase from 200 to 4000.

Index: b/kern/zalloc.c
===================================================================
--- a/kern/zalloc.c
+++ b/kern/zalloc.c
@@ -105,7 +105,7 @@ zone_t		zone_zone;	/* this is the zone c
 boolean_t	zone_ignore_overflow = TRUE;
 
 vm_map_t	zone_map = VM_MAP_NULL;
-vm_size_t	zone_map_size = 12 * 1024 * 1024;
+vm_size_t	zone_map_size = 64 * 1024 * 1024;
 
 /*
  *	The VM system gives us an initial chunk of memory.
Index: b/vm/vm_object.c
===================================================================
--- a/vm/vm_object.c
+++ b/vm/vm_object.c
@@ -179,7 +179,7 @@ vm_object_t	kernel_object;
  */
 queue_head_t	vm_object_cached_list;
 int		vm_object_cached_count;
-int		vm_object_cached_max = 200;	/* may be patched*/
+int		vm_object_cached_max = 4000;	/* may be patched*/
 
 decl_simple_lock_data(,vm_object_cached_lock_data)
 
Index: b/vm/vm_map.h
===================================================================
--- a/vm/vm_map.h
+++ b/vm/vm_map.h
@@ -226,7 +226,7 @@ typedef struct vm_map_version {
  *		(returned) and an abort flag (abort if TRUE).
  */
 
-#define VM_MAP_COPY_PAGE_LIST_MAX	8
+#define VM_MAP_COPY_PAGE_LIST_MAX	64
 
 typedef struct vm_map_copy {
 	int			type;
Index: b/i386/i386at/model_dep.c
===================================================================
--- a/i386/i386at/model_dep.c	10 Nov 2008 15:18:47 -0000	1.9.2.19
+++ b/i386/i386at/model_dep.c	11 Jun 2009 00:32:30 -0000
@@ -231,10 +232,10 @@ mem_size_init(void)
 	printf("AT386 boot: physical memory from 0x%x to 0x%x\n",
 	       phys_first_addr, phys_last_addr);
 
-	/* Reserve 1/16 of the memory address space for virtual mappings.
+	/* Reserve 1/8 of the memory address space for virtual mappings.
 	 * Yes, this loses memory.  Blame i386.  */
-	if (phys_last_addr > (VM_MAX_KERNEL_ADDRESS / 16) * 15)
-		phys_last_addr = (VM_MAX_KERNEL_ADDRESS / 16) * 15;
+	if (phys_last_addr > (VM_MAX_KERNEL_ADDRESS / 8) * 7)
+		phys_last_addr = (VM_MAX_KERNEL_ADDRESS / 8) * 7;
 
 	phys_first_addr = round_page(phys_first_addr);
 	phys_last_addr = trunc_page(phys_last_addr);
